diff -urNw stock-kernel/drivers/input/asusec/Makefile linux/drivers/input/asusec/Makefile
--- stock-kernel/drivers/input/asusec/Makefile	2012-09-13 08:32:35.000000000 +0200
+++ linux/drivers/input/asusec/Makefile	2013-01-31 11:10:05.670032325 +0100
@@ -1,3 +1,4 @@
 obj-$(CONFIG_ASUSPEC)		+= asuspec.o
 obj-$(CONFIG_ASUSDEC)		+= asusdec.o
 obj-$(CONFIG_ASUSDEC)		+= elan_i2c_asus.o
+obj-$(CONFIG_ASUSDEC)		+= elan_i2c_hack.o
diff -urNw stock-kernel/drivers/input/asusec/asusdec.c linux/drivers/input/asusec/asusdec.c
--- stock-kernel/drivers/input/asusec/asusdec.c	2012-09-13 08:32:35.000000000 +0200
+++ linux/drivers/input/asusec/asusdec.c	2013-01-31 11:16:47.370000664 +0100
@@ -453,7 +453,7 @@
 static void asusdec_fw_reset_ec_op(void){
 	char i2c_data[32];
 	int i;
-	int r_data[32];
+	//int r_data[32];

 	asusdec_fw_clear_buf();

@@ -468,7 +468,7 @@
 static void asusdec_fw_address_set_op(void){
 	char i2c_data[32];
 	int i;
-	int r_data[32];
+	//int r_data[32];

 	asusdec_fw_clear_buf();

@@ -487,7 +487,7 @@
 static void asusdec_fw_enter_op(void){
 	char i2c_data[32];
 	int i;
-	int r_data[32];
+	//int r_data[32];

 	asusdec_fw_clear_buf();

@@ -872,7 +872,9 @@
 {
 	int rc = 0 ;
 	unsigned gpio = asusdec_ecreq_gpio;
+#if ASUSDEC_DEBUG
 	unsigned irq = gpio_to_irq(asusdec_apwake_gpio);
+#endif
 	const char* label = "asusdec_request" ;

 	ASUSDEC_INFO("gpio = %d, irq = %d\n", gpio, irq);
@@ -1454,7 +1456,7 @@

 static void asusdec_dock_status_report(void){
 	ASUSDEC_INFO("dock_in = %d\n", ec_chip->dock_in);
-	switch_set_state(&ec_chip->dock_sdev, switch_value[ec_chip->dock_type]);
+	switch_set_state(&ec_chip->dock_sdev, (int)switch_value[ec_chip->dock_type]);
 #if BATTERY_DRIVER
 	queue_delayed_work(asusdec_wq, &ec_chip->asusdec_pad_battery_report_work, 0);
 #endif
@@ -1538,7 +1540,7 @@
 static void asusdec_dock_init_work_function(struct work_struct *dat)
 {
 	int gpio = asusdec_dock_in_gpio;
-	int irq = gpio_to_irq(gpio);
+	//int irq = gpio_to_irq(gpio);
 	int i = 0;
 	int d_counter = 0;
 	int gpio_state = 0;
@@ -1673,14 +1675,15 @@

 static void asusAudiodec_work_function(struct work_struct *dat)
 {
-	// Audio Dock EC function Service
-	ASUSDEC_NOTICE("cmd 0x6a i2c_smbus read 8 byte datas\n");
-	int ret_val = 0;
+	//int ret_val = 0;
 	int mcu_cable_type = 0, bat_cable_type = 0;
 	int gpio = asusdec_apwake_gpio;
 	int irq = gpio_to_irq(gpio);

-	ret_val = asusdec_i2c_read_data(ec_chip->client);
+	// Audio Dock EC function Service
+	ASUSDEC_NOTICE("cmd 0x6a i2c_smbus read 8 byte datas\n");
+
+	/*ret_val =*/ asusdec_i2c_read_data(ec_chip->client);
 #if BATTERY_DRIVER
 		if (ec_chip->dock_type == AUDIO_DOCK) {
 			mcu_cable_type = asusAudiodec_cable_type_callback();
diff -urNw stock-kernel/drivers/input/asusec/asusdec.h linux/drivers/input/asusec/asusdec.h
--- stock-kernel/drivers/input/asusec/asusdec.h	2012-09-13 08:32:35.000000000 +0200
+++ linux/drivers/input/asusec/asusdec.h	2013-01-21 16:39:43.490024735 +0100
@@ -25,14 +25,14 @@
 						for (i = 0; i < array[0]+1; i++) \
 							ASUSDEC_INFO("ec_data[%d] = 0x%x\n", i, array[i]);	\
 					} while(0)
+#define ASUSDEC_NOTICE(format, arg...)  \
+        printk(KERN_NOTICE "asusdec: [%s] " format , __FUNCTION__ , ## arg)
 #else
 #define ASUSDEC_INFO(format, arg...)
 #define ASUSDEC_I2C_DATA(array, i)
+#define ASUSDEC_NOTICE(format, arg...)
 #endif

-#define ASUSDEC_NOTICE(format, arg...)	\
-	printk(KERN_NOTICE "asusdec: [%s] " format , __FUNCTION__ , ## arg)
-
 #define ASUSDEC_ERR(format, arg...)	\
 	printk(KERN_ERR "asusdec: [%s] " format , __FUNCTION__ , ## arg)

@@ -45,7 +45,6 @@
 #define ASUSDEC_I2C_ERR_TOLERANCE	8
 #define ASUSDEC_RETRY_COUNT		3
 #define ASUSDEC_POLLING_RATE		80
-
 #define ASUSDEC_OBF_MASK		0x1
 #define ASUSDEC_KEY_MASK		0x4
 #define ASUSDEC_KBC_MASK		0x8
diff -urNw stock-kernel/drivers/input/asusec/elan_i2c_asus.c linux/drivers/input/asusec/elan_i2c_asus.c
--- stock-kernel/drivers/input/asusec/elan_i2c_asus.c   2012-09-13 08:32:35.000000000 +0200
+++ linux/drivers/input/asusec/elan_i2c_asus.c  2013-02-01 08:09:35.610008748 +0100
@@ -30,7 +30,9 @@
        int i;
        int retry_data_count;
        u8 i2c_data[16];
+#if ASUSDEC_DEBUG
        int index;
+#endif

        ELAN_INFO("command = 0x%x\n",command);
        asus_ec_cmd = (((command & 0x00ff) << 8) | 0xD4);
@@ -74,6 +76,11 @@

 }

+int elan_i2c_asus_cmd_hack(struct i2c_client *client,unsigned char *param, int command)
+{
+       return elan_i2c_asus_cmd(client,param,command);
+}
+
 /*
  * Interpret complete data packets and report absolute mode input events for
  * hardware version 2. (6 byte packets)
@@ -94,6 +101,9 @@
        dev = etd->abs_dev;
        packet = ec_chip->ec_data;

+       // call hack handler
+       elantech_report_hack_absolute_v2(ec_chip->private->hack_dev, packet);
+
        // Report multitouch events for fingers.
        fingers = (packet[0] & 0xc0) >> 6;
        x = ((packet[1] & 0x0f) << 8) | packet[2];
@@ -252,7 +262,6 @@

 }

-
 /*
  * Use magic knock to detect Elantech touchpad
  */
@@ -291,8 +300,12 @@
  */
 int elantech_init(struct asusdec_chip *ec_chip)
 {
+       struct input_dev *itmp;
+       int ret;
+
        ELAN_INFO("Elan et1059 elantech_init\n");

+
        if (elantech_set_absolute_mode(ec_chip)){
                ELAN_ERR("failed to put touchpad into absolute mode.\n");
                return -1;
@@ -301,6 +314,22 @@
                ELAN_ERR("failed to elantech_set_input_rel_params.\n");
                return -1;
        }
+
+       itmp = elantech_create_hack_input(ec_chip->client);
+       if(itmp)
+       {
+               if((ret = input_register_device(itmp)) < 0)
+               {
+                       printk("hacking: failed to registrate device [%d]\n",ret);
+                       input_free_device(itmp);
+               }
+               else
+               {
+                       ec_chip->private->hack_dev = itmp;
+               }
+       }
+       else
+               printk("hacking: elantech_create_hack_input return NULL\n");
        //elan_i2c_asus_cmd(ec_chip->client,  NULL, PSMOUSE_CMD_ENABLE);
        return 0;
 }
diff -urNw stock-kernel/drivers/input/asusec/elan_i2c_asus.h linux/drivers/input/asusec/elan_i2c_asus.h
--- stock-kernel/drivers/input/asusec/elan_i2c_asus.h   2012-09-13 08:32:35.000000000 +0200
+++ linux/drivers/input/asusec/elan_i2c_asus.h  2013-02-01 08:08:53.850008683 +0100
@@ -2,6 +2,7 @@
 #define _ELAN_I2C_ASUS_H

 #include "asusdec.h"
+#include <linux/input.h>

 #define ELAN_DEBUG                     0
 #if ELAN_DEBUG
@@ -99,7 +100,7 @@
  * Hence the X and Y ranges are doubled too.
  * The bezel around the pad also appears to be smaller
  */
-#define ETP_EDGE_FUZZ_V2               0
+#define ETP_EDGE_FUZZ_V2               8

 #define ETP_XMIN_V2                    (   0 + ETP_EDGE_FUZZ_V2)
 #define ETP_XMAX_V2                    (1152 - ETP_EDGE_FUZZ_V2)
@@ -109,11 +110,16 @@
 #define ETP_WMIN_V2                     0
 #define ETP_WMAX_V2                     15

+#define ETP_PMIN_V2                    0
+#define ETP_PMAX_V2                    255
+#define ETP_WMIN_V2                    0
+#define ETP_WMAX_V2                    15
+
 /*
  * For two finger touches the coordinate of each finger gets reported
  * separately but with reduced resolution.
  */
-#define ETP_2FT_FUZZ                   0
+#define ETP_2FT_FUZZ                   4

 #define ETP_2FT_XMIN                   (  0 + ETP_2FT_FUZZ)
 #define ETP_2FT_XMAX                   (288 - ETP_2FT_FUZZ)
@@ -132,11 +138,15 @@
        struct { int x, y; } pos[2];

        struct input_dev *abs_dev;
+       struct input_dev *hack_dev;
 };

+int elan_i2c_asus_cmd_hack(struct i2c_client *,unsigned char *, int);
 int elantech_detect(struct asusdec_chip *ec_chip);
 int elantech_init(struct asusdec_chip *ec_chip);
 void elantech_report_absolute_to_related(struct asusdec_chip *ec_chip, int *Null_data_times);
+struct input_dev *elantech_create_hack_input(struct i2c_client *);
+void elantech_report_hack_absolute_v2(struct input_dev *, unsigned char *);
 #endif


diff -urNw stock-kernel/drivers/input/asusec/elan_i2c_hack.c linux/drivers/input/asusec/elan_i2c_hack.c
--- stock-kernel/drivers/input/asusec/elan_i2c_hack.c	1970-01-01 01:00:00.000000000 +0100
+++ linux/drivers/input/asusec/elan_i2c_hack.c	2013-01-31 13:49:39.780000503 +0100
@@ -0,0 +1,241 @@
+/*
+ * Elantech Touchpad driver (v6) : asusdec hack
+ *
+ * Copyright (C) 2007-2009 Arjan Opmeer <arjan@opmeer.net>
+ * Copyright (C) 2013 Massimo Dragano <massimo.dragano@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published
+ * by the Free Software Foundation.
+ *
+ * Trademarks are the property of their respective owners.
+ */
+
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/gpio.h>
+#include <linux/i2c.h>
+#include <linux/init.h>
+#include <linux/input.h>
+#include <linux/input/mt.h>
+#include <linux/interrupt.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/input/mt.h>
+#include <linux/workqueue.h>
+#include "elan_i2c_asus.h"
+
+struct input_dev *elantech_create_hack_input(struct i2c_client *client)
+{
+	struct input_dev *dev;
+	unsigned char dummy_buff[2];
+
+	dev = input_allocate_device();
+	if (dev == NULL)
+		return NULL;
+
+	dev->name = "Elantech Touchpad";
+	dev->phys = client->adapter->name;
+	dev->id.bustype = BUS_I2C;
+
+	__set_bit(EV_KEY, dev->evbit);
+	__set_bit(EV_ABS, dev->evbit);
+	__clear_bit(EV_REL, dev->evbit);
+
+	__set_bit(BTN_LEFT, dev->keybit);
+	__set_bit(BTN_RIGHT, dev->keybit);
+
+	__set_bit(BTN_TOUCH, dev->keybit);
+	__set_bit(BTN_TOOL_FINGER, dev->keybit);
+	__set_bit(BTN_TOOL_DOUBLETAP, dev->keybit);
+	__set_bit(BTN_TOOL_TRIPLETAP, dev->keybit);
+	__set_bit(BTN_TOOL_QUADTAP, dev->keybit);
+
+	__set_bit(INPUT_PROP_SEMI_MT, dev->propbit);
+
+	if ((elan_i2c_asus_cmd_hack(client, NULL, ETP_PS2_CUSTOM_COMMAND)) ||
+	    (elan_i2c_asus_cmd_hack(client, NULL, 0x0000)) ||
+	    (elan_i2c_asus_cmd_hack(client, dummy_buff, PSMOUSE_CMD_GETINFO))
+		 )
+	{
+		input_free_device(dev);
+		return NULL;
+	}
+
+	/* X Y Value */
+	input_set_abs_params(dev, ABS_X, ETP_XMIN_V2, ETP_XMAX_V2, 0, 0);
+	input_set_abs_params(dev, ABS_Y, ETP_YMIN_V2, ETP_YMAX_V2, 0, 0);
+	/* Finger Pressure value */
+	input_set_abs_params(dev, ABS_PRESSURE, ETP_PMIN_V2, ETP_PMAX_V2, 0, 0);
+
+	/* Palme Value */
+	input_set_abs_params(dev, ABS_TOOL_WIDTH, ETP_WMIN_V2, ETP_WMAX_V2, 0, 0);
+
+	/* per finger X Y values */
+	input_mt_init_slots(dev, 2);
+	input_set_abs_params(dev, ABS_MT_POSITION_X, ETP_XMIN_V2, ETP_XMAX_V2, 0, 0);
+	input_set_abs_params(dev, ABS_MT_POSITION_Y, ETP_YMIN_V2, ETP_YMAX_V2, 0, 0);
+
+	/* Enable ABS mode*/
+	if ((elan_i2c_asus_cmd_hack(client, NULL, ETP_PS2_CUSTOM_COMMAND)) ||
+			(elan_i2c_asus_cmd_hack(client, NULL, ETP_REGISTER_RW)) ||
+			(elan_i2c_asus_cmd_hack(client, NULL, ETP_PS2_CUSTOM_COMMAND)) ||
+			(elan_i2c_asus_cmd_hack(client, NULL, 0x0010)) ||
+			(elan_i2c_asus_cmd_hack(client, NULL, ETP_PS2_CUSTOM_COMMAND)) ||
+			(elan_i2c_asus_cmd_hack(client, NULL, 0x03)) || // reg_10
+			(elan_i2c_asus_cmd_hack(client, NULL, PSMOUSE_CMD_SETSCALE11)))
+	{
+		input_free_device(dev);
+		return NULL;
+	}
+
+	return dev;
+}
+
+void elantech_set_slot(struct input_dev *dev, int slot, bool active,
+			      unsigned int x, unsigned int y)
+{
+	input_mt_slot(dev, slot);
+	input_mt_report_slot_state(dev, MT_TOOL_FINGER, active);
+	if (active) {
+		input_report_abs(dev, ABS_MT_POSITION_X, x);
+		input_report_abs(dev, ABS_MT_POSITION_Y, y);
+	}
+}
+
+/* x1 < x2 and y1 < y2 when two fingers, x = y = 0 when not pressed */
+void elantech_report_semi_mt_data(struct input_dev *dev,
+					 unsigned int num_fingers,
+					 unsigned int x1, unsigned int y1,
+					 unsigned int x2, unsigned int y2)
+{
+	elantech_set_slot(dev, 0, num_fingers != 0, x1, y1);
+	elantech_set_slot(dev, 1, num_fingers == 2, x2, y2);
+}
+
+/*
+ * Interpret complete data packets and report absolute mode input events for
+ * hardware version 2. (6 byte packets)
+ */
+void elantech_report_hack_absolute_v2(struct input_dev *dev, unsigned char *packet)
+{
+	unsigned int fingers, x1 = 0, y1 = 0, x2 = 0, y2 = 0, width = 0, pres = 0;
+
+	/* byte 0: n1  n0   .   .   .   .   R   L */
+	fingers = (packet[0] & 0xc0) >> 6;
+	input_report_key(dev, BTN_TOUCH, fingers != 0);
+
+	switch (fingers) {
+	case 3:
+		/*
+		 * Same as one finger, except report of more than 3 fingers:
+		 * byte 3:  n4  .   w1  w0   .   .   .   .
+		 */
+		if (packet[3] & 0x80)
+			fingers = 4;
+		/* pass through... */
+	case 1:
+		/*
+		 * byte 1:  .   .   .   .   .  x10 x9  x8
+		 * byte 2: x7  x6  x5  x4  x4  x2  x1  x0
+		 */
+		x1 = ((packet[1] & 0x07) << 8) | packet[2];
+		/*
+		 * byte 4:  .   .   .   .   .   .  y9  y8
+		 * byte 5: y7  y6  y5  y4  y3  y2  y1  y0
+		 */
+		y1 = ETP_YMAX_V2 - (((packet[4] & 0x03) << 8) | packet[5]);
+
+		input_report_abs(dev, ABS_X, x1);
+		input_report_abs(dev, ABS_Y, y1);
+
+		pres = (packet[1] & 0xf0) | ((packet[4] & 0xf0) >> 4);
+		width = ((packet[0] & 0x30) >> 2) | ((packet[3] & 0x30) >> 4);
+		break;
+
+	case 2:
+		/*
+		 * The coordinate of each finger is reported separately
+		 * with a lower resolution for two finger touches:
+		 * byte 0:  .   .  ay8 ax8  .   .   .   .
+		 * byte 1: ax7 ax6 ax5 ax4 ax3 ax2 ax1 ax0
+		 */
+		x1 = ((packet[0] & 0x10) << 4) | packet[1];
+		/* byte 2: ay7 ay6 ay5 ay4 ay3 ay2 ay1 ay0 */
+		y1 = ETP_2FT_YMAX - (((packet[0] & 0x20) << 3) | packet[2]);
+		/*
+		 * byte 3:  .   .  by8 bx8  .   .   .   .
+		 * byte 4: bx7 bx6 bx5 bx4 bx3 bx2 bx1 bx0
+		 */
+		x2 = ((packet[3] & 0x10) << 4) | packet[4];
+		/* byte 5: by7 by8 by5 by4 by3 by2 by1 by0 */
+		y2 = ETP_2FT_YMAX - (((packet[3] & 0x20) << 3) | packet[5]);
+		/*
+		 * For compatibility with the X Synaptics driver scale up
+		 * one coordinate and report as ordinary mouse movent
+		 */
+		input_report_abs(dev, ABS_X, x1 << 2);
+		input_report_abs(dev, ABS_Y, y1 << 2);
+
+		/* Unknown so just report sensible values */
+		pres = 127;
+		width = 7;
+		break;
+	}
+
+	elantech_report_semi_mt_data(dev, fingers, x1, y1, x2, y2);
+	input_report_key(dev, BTN_TOOL_FINGER, fingers == 1);
+	input_report_key(dev, BTN_TOOL_DOUBLETAP, fingers == 2);
+	input_report_key(dev, BTN_TOOL_TRIPLETAP, fingers == 3);
+	input_report_key(dev, BTN_TOOL_QUADTAP, fingers == 4);
+	input_report_key(dev, BTN_LEFT, packet[0] & 0x01);
+	input_report_key(dev, BTN_RIGHT, packet[0] & 0x02);
+	input_report_abs(dev, ABS_PRESSURE, pres);
+	input_report_abs(dev, ABS_TOOL_WIDTH, width);
+
+	input_sync(dev);
+}
+
diff -urNw stock-kernel/drivers/ril/ril.c linux/drivers/ril/ril.c
--- stock-kernel/drivers/ril/ril.c	2012-09-13 08:32:35.000000000 +0200
+++ linux/drivers/ril/ril.c	2012-11-26 19:38:59.000000000 +0100
@@ -8,7 +8,7 @@
 #include <linux/switch.h>
 #include <linux/uaccess.h>
 #include <linux/workqueue.h>
-#include <../../arch/arm/mach-tegra/include/mach/board-cardhu-misc.h>
+#include "../../arch/arm/mach-tegra/include/mach/board-cardhu-misc.h"

 #include "pm-irq.h"
 #include "ril.h"
diff -urNw stock-kernel/net/wireless/chan.c linux/net/wireless/chan.c
--- stock-kernel/net/wireless/chan.c	2012-09-13 08:32:35.000000000 +0200
+++ linux/net/wireless/chan.c	2013-01-16 14:17:01.689868924 +0100
@@ -82,9 +82,12 @@
 {
 	struct ieee80211_channel *chan;
 	int result;
+	struct wireless_dev *mon_dev = NULL;

-	if (wdev && wdev->iftype == NL80211_IFTYPE_MONITOR)
+	if (wdev && wdev->iftype == NL80211_IFTYPE_MONITOR) {
+		mon_dev = wdev;
 		wdev = NULL;
+	}

 	if (wdev) {
 		ASSERT_WDEV_LOCK(wdev);
@@ -131,5 +134,8 @@
 	if (wdev)
 		wdev->channel = chan;

+	if (mon_dev)
+		mon_dev->channel = chan;
+
 	return 0;
 }
