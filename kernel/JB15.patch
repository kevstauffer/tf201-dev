diff -urNw stock-kernel/drivers/input/asusec/Makefile linux/drivers/input/asusec/Makefile
--- stock-kernel/drivers/input/asusec/Makefile	2012-09-13 08:32:35.000000000 +0200
+++ linux/drivers/input/asusec/Makefile	2013-01-31 11:10:05.670032325 +0100
@@ -1,3 +1,4 @@
 obj-$(CONFIG_ASUSPEC)		+= asuspec.o
 obj-$(CONFIG_ASUSDEC)		+= asusdec.o
 obj-$(CONFIG_ASUSDEC)		+= elan_i2c_asus.o
+obj-$(CONFIG_ASUSDEC)		+= elan_i2c_hack.o
diff -urNw stock-kernel/drivers/input/asusec/asusdec.c linux/drivers/input/asusec/asusdec.c
--- stock-kernel/drivers/input/asusec/asusdec.c	2012-09-13 08:32:35.000000000 +0200
+++ linux/drivers/input/asusec/asusdec.c	2013-01-31 11:16:47.370000664 +0100
@@ -453,7 +453,7 @@
 static void asusdec_fw_reset_ec_op(void){
 	char i2c_data[32];
 	int i;
-	int r_data[32];
+	//int r_data[32];
 
 	asusdec_fw_clear_buf();
 	
@@ -468,7 +468,7 @@
 static void asusdec_fw_address_set_op(void){
 	char i2c_data[32];
 	int i;
-	int r_data[32];
+	//int r_data[32];
 
 	asusdec_fw_clear_buf();
 
@@ -487,7 +487,7 @@
 static void asusdec_fw_enter_op(void){
 	char i2c_data[32];
 	int i;
-	int r_data[32];
+	//int r_data[32];
 
 	asusdec_fw_clear_buf();
 
@@ -872,7 +872,9 @@
 {
 	int rc = 0 ;
 	unsigned gpio = asusdec_ecreq_gpio;
+#if ASUSDEC_DEBUG
 	unsigned irq = gpio_to_irq(asusdec_apwake_gpio);
+#endif
 	const char* label = "asusdec_request" ; 
 
 	ASUSDEC_INFO("gpio = %d, irq = %d\n", gpio, irq);
@@ -1454,7 +1456,7 @@
 
 static void asusdec_dock_status_report(void){
 	ASUSDEC_INFO("dock_in = %d\n", ec_chip->dock_in);
-	switch_set_state(&ec_chip->dock_sdev, switch_value[ec_chip->dock_type]);
+	switch_set_state(&ec_chip->dock_sdev, (int)switch_value[ec_chip->dock_type]);
 #if BATTERY_DRIVER
 	queue_delayed_work(asusdec_wq, &ec_chip->asusdec_pad_battery_report_work, 0);
 #endif
@@ -1538,7 +1540,7 @@
 static void asusdec_dock_init_work_function(struct work_struct *dat)
 {
 	int gpio = asusdec_dock_in_gpio;
-	int irq = gpio_to_irq(gpio);
+	//int irq = gpio_to_irq(gpio);
 	int i = 0;
 	int d_counter = 0;
 	int gpio_state = 0;
@@ -1673,14 +1675,15 @@
 
 static void asusAudiodec_work_function(struct work_struct *dat)
 {
-	// Audio Dock EC function Service
-	ASUSDEC_NOTICE("cmd 0x6a i2c_smbus read 8 byte datas\n");
-	int ret_val = 0;
+	//int ret_val = 0;
 	int mcu_cable_type = 0, bat_cable_type = 0;
 	int gpio = asusdec_apwake_gpio;
 	int irq = gpio_to_irq(gpio);
 
-	ret_val = asusdec_i2c_read_data(ec_chip->client);
+	// Audio Dock EC function Service
+	ASUSDEC_NOTICE("cmd 0x6a i2c_smbus read 8 byte datas\n");
+
+	/*ret_val =*/ asusdec_i2c_read_data(ec_chip->client);
 #if BATTERY_DRIVER
 		if (ec_chip->dock_type == AUDIO_DOCK) {
 			mcu_cable_type = asusAudiodec_cable_type_callback();
diff -urNw stock-kernel/drivers/input/asusec/asusdec.h linux/drivers/input/asusec/asusdec.h
--- stock-kernel/drivers/input/asusec/asusdec.h	2012-09-13 08:32:35.000000000 +0200
+++ linux/drivers/input/asusec/asusdec.h	2013-01-21 16:39:43.490024735 +0100
@@ -25,14 +25,14 @@
 						for (i = 0; i < array[0]+1; i++) \
 							ASUSDEC_INFO("ec_data[%d] = 0x%x\n", i, array[i]);	\
 					} while(0)
+#define ASUSDEC_NOTICE(format, arg...)  \
+        printk(KERN_NOTICE "asusdec: [%s] " format , __FUNCTION__ , ## arg)
 #else
 #define ASUSDEC_INFO(format, arg...)	 
 #define ASUSDEC_I2C_DATA(array, i)
+#define ASUSDEC_NOTICE(format, arg...)
 #endif
 
-#define ASUSDEC_NOTICE(format, arg...)	\
-	printk(KERN_NOTICE "asusdec: [%s] " format , __FUNCTION__ , ## arg)
-
 #define ASUSDEC_ERR(format, arg...)	\
 	printk(KERN_ERR "asusdec: [%s] " format , __FUNCTION__ , ## arg)
 
@@ -45,7 +45,6 @@
 #define ASUSDEC_I2C_ERR_TOLERANCE	8
 #define ASUSDEC_RETRY_COUNT		3
 #define ASUSDEC_POLLING_RATE		80
-
 #define ASUSDEC_OBF_MASK		0x1
 #define ASUSDEC_KEY_MASK		0x4
 #define ASUSDEC_KBC_MASK		0x8
diff -urNw stock-kernel/drivers/input/asusec/elan_i2c_asus.c linux/drivers/input/asusec/elan_i2c_asus.c
--- stock-kernel/drivers/input/asusec/elan_i2c_asus.c	2012-09-13 08:32:35.000000000 +0200
+++ linux/drivers/input/asusec/elan_i2c_asus.c	2013-01-31 11:25:53.910000006 +0100
@@ -30,7 +30,9 @@
 	int i;
 	int retry_data_count;
 	u8 i2c_data[16];
+#if ASUSDEC_DEBUG
 	int index;
+#endif
 
 	ELAN_INFO("command = 0x%x\n",command);
 	asus_ec_cmd = (((command & 0x00ff) << 8) | 0xD4);
@@ -74,6 +76,11 @@
   
 }
 
+int elan_i2c_asus_cmd_hack(struct i2c_client *client,unsigned char *param, int command)
+{
+	return elan_i2c_asus_cmd(client,param,command);
+}
+
 /*
  * Interpret complete data packets and report absolute mode input events for
  * hardware version 2. (6 byte packets)
@@ -167,6 +174,8 @@
 	}
 	
 	input_sync(dev);
+
+	elantech_i2c_report_absolute(ec_chip->private->elan_hack, (uint8_t *)packet);
 }
 
 /*
@@ -252,7 +261,6 @@
   
 }
 
-
 /*
  * Use magic knock to detect Elantech touchpad
  */
@@ -291,8 +299,12 @@
  */
 int elantech_init(struct asusdec_chip *ec_chip)
 {  
+	struct elantech_i2c *etmp;
+	int ret;
+
 	ELAN_INFO("Elan et1059 elantech_init\n");
 	
+
 	if (elantech_set_absolute_mode(ec_chip)){
 		ELAN_ERR("failed to put touchpad into absolute mode.\n");
 		return -1;
@@ -301,6 +313,30 @@
 		ELAN_ERR("failed to elantech_set_input_rel_params.\n");
 		return -1;
 	}
+
+	printk("hacking: elantech successfully initialized.\n");
+	etmp = elantech_i2c_priv_create(ec_chip->client);
+	if(etmp)
+	{
+		printk("hacking: elantech_i2c_priv_create succeded!\nhacking: going to register the returned device\n");
+		if((ret = input_register_device(etmp->input)) < 0)
+		{
+			printk("hacking: failed to registrate device [%d]\n",ret);
+			printk("hacking: name => %s\nhacking: phys => %s\n",etmp->input->name,etmp->input->phys);
+			input_free_device(etmp->input);
+			kfree(etmp);
+		}
+		else
+		{
+			printk("hacking: we did it!\n");
+			ec_chip->private->elan_hack = etmp;
+			//i2c_set_clientdata(ec_chip->client, etmp);
+			//device_init_wakeup(&ec_chip->client->dev, 1);
+			elan_i2c_asus_cmd(ec_chip->client,  NULL, PSMOUSE_CMD_ENABLE);
+		}
+	}
+	else
+		printk("hacking: elantech_i2c_priv_create return NULL\n");
 	//elan_i2c_asus_cmd(ec_chip->client,  NULL, PSMOUSE_CMD_ENABLE);
 	return 0;
 }
diff -urNw stock-kernel/drivers/input/asusec/elan_i2c_asus.h linux/drivers/input/asusec/elan_i2c_asus.h
--- stock-kernel/drivers/input/asusec/elan_i2c_asus.h	2012-09-13 08:32:35.000000000 +0200
+++ linux/drivers/input/asusec/elan_i2c_asus.h	2013-01-31 11:24:11.819991619 +0100
@@ -2,6 +2,7 @@
 #define _ELAN_I2C_ASUS_H
 
 #include "asusdec.h"
+#include <linux/input.h>
 
 #define ELAN_DEBUG			0
 #if ELAN_DEBUG
@@ -120,6 +121,32 @@
 #define ETP_2FT_YMIN			(  0 + ETP_2FT_FUZZ)
 #define ETP_2FT_YMAX			(192 - ETP_2FT_FUZZ)
 
+#define ETP_FINGER_DATA_OFFSET	4
+#define ETP_FINGER_DATA_LEN	5
+#define ETP_I2C_COMMAND_TRIES	3
+#define ETP_I2C_COMMAND_DELAY	500
+/* Length of Elan Touchpad information */
+#define ETP_INF_LENGTH		2
+#define ETP_MAX_FINGERS		5
+#define ETP_PACKET_LENGTH	30
+#define ETP_REPORT_ID		0X5d
+#define ETP_REPORT_MAX_LENGTH	79
+#define ETP_PRESSURE_MAX	0xff
+#define HID_DES_LENGTH_OFFSET	1
+
+struct elantech_i2c {
+	struct i2c_client	*client;
+	struct input_dev	*input;
+	struct work_struct	work;
+	unsigned int		gpio;
+	unsigned int		max_x;
+	unsigned int		max_y;
+	unsigned int		width_x;
+	unsigned int		width_y;
+	int			irq;
+	u8			pre_recv[28];
+};
+
 struct elantech_data {
 	unsigned int xmax;
 	unsigned int ymax;
@@ -132,11 +159,15 @@
 	struct { int x, y; } pos[2];
 
 	struct input_dev *abs_dev;
+	struct elantech_i2c *elan_hack;
 };
 
+int elan_i2c_asus_cmd_hack(struct i2c_client *,unsigned char *, int);
 int elantech_detect(struct asusdec_chip *ec_chip);
 int elantech_init(struct asusdec_chip *ec_chip);
 void elantech_report_absolute_to_related(struct asusdec_chip *ec_chip, int *Null_data_times);
+void elantech_i2c_report_absolute(struct elantech_i2c *, uint8_t *);
+struct elantech_i2c *elantech_i2c_priv_create(struct i2c_client *);
 #endif
 
 
diff -urNw stock-kernel/drivers/input/asusec/elan_i2c_hack.c linux/drivers/input/asusec/elan_i2c_hack.c
--- stock-kernel/drivers/input/asusec/elan_i2c_hack.c	1970-01-01 01:00:00.000000000 +0100
+++ linux/drivers/input/asusec/elan_i2c_hack.c	2013-01-31 13:49:39.780000503 +0100
@@ -0,0 +1,241 @@
+/*
+ * Elantech I2C Touchpad diver
+ *
+ * Copyright (c) 2011-2012 Tom Lin (Lin Yen Yu) <tom_lin@emc.com.tw>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published
+ * by the Free Software Foundation.
+ *
+ * Trademarks are the property of their respective owners.
+ */
+
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/gpio.h>
+#include <linux/i2c.h>
+#include <linux/init.h>
+#include <linux/input.h>
+#include <linux/input/mt.h>
+#include <linux/interrupt.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/input/mt.h>
+#include <linux/workqueue.h>
+#include "elan_i2c_asus.h"
+
+struct elantech_i2c *elantech_i2c_priv_create(struct i2c_client *client)
+{
+	struct elantech_i2c *elantech_i2c_priv;
+	struct input_dev *dev;
+	unsigned int gpio;
+	//const char *label = "elantech_i2c";
+	//int rc = 0;
+	unsigned char buf_recv[2];
+
+	elantech_i2c_priv = kzalloc(sizeof(struct elantech_i2c), GFP_KERNEL);
+	if (!elantech_i2c_priv)
+		return NULL;
+
+	elantech_i2c_priv->client = client;
+	elantech_i2c_priv->irq = client->irq;
+	elantech_i2c_priv->input = input_allocate_device();
+	if (elantech_i2c_priv->input == NULL)
+		goto err_input_allocate_device;
+
+	elantech_i2c_priv->input->name = "ELANTECH_I2C";
+	elantech_i2c_priv->input->phys = client->adapter->name;
+	elantech_i2c_priv->input->id.bustype = BUS_I2C;
+
+	dev = elantech_i2c_priv->input;
+	__set_bit(EV_KEY, dev->evbit);
+	__set_bit(EV_ABS, dev->evbit);
+
+	__set_bit(BTN_LEFT, dev->keybit);
+	__set_bit(BTN_RIGHT, dev->keybit);
+	//__set_bit(BTN_MIDDLE, dev->keybit);
+
+	__set_bit(BTN_TOUCH, dev->keybit);
+	__set_bit(BTN_TOOL_FINGER, dev->keybit);
+	__set_bit(BTN_TOOL_DOUBLETAP, dev->keybit);
+	__set_bit(BTN_TOOL_TRIPLETAP, dev->keybit);
+	__set_bit(BTN_TOOL_QUADTAP, dev->keybit);
+
+
+	if ((elan_i2c_asus_cmd_hack(client, NULL, ETP_PS2_CUSTOM_COMMAND)) ||
+	    (elan_i2c_asus_cmd_hack(client, NULL, 0x0000)) ||
+	    (elan_i2c_asus_cmd_hack(client, buf_recv, PSMOUSE_CMD_GETINFO))
+		 )
+		goto	err_gpio_request;
+
+	elantech_i2c_priv->max_x = (0x0F & buf_recv[0]) << 8 | buf_recv[1];
+	elantech_i2c_priv->max_y = (0xF0 & buf_recv[0]) << 4 | buf_recv[2];
+
+
+	/*
+	elantech_i2c_command(client, ETP_X_AXIS_MAX_CMD, buf_recv, ETP_INF_LENGTH);
+	elantech_i2c_priv->max_x = (0x0f & buf_recv[1]) << 8 | buf_recv[0];
+	elantech_i2c_command(client, ETP_Y_AXIS_MAX_CMD, buf_recv, ETP_INF_LENGTH);
+	elantech_i2c_priv->max_y = (0x0f & buf_recv[1]) << 8 | buf_recv[0];
+	*/
+	dev_info(&client->dev, "%s max_x = %d\n", __func__, elantech_i2c_priv->max_x);
+	dev_info(&client->dev, "%s max_y = %d\n", __func__, elantech_i2c_priv->max_y);
+	/*
+	elantech_i2c_command(client, ETP_TRACE_NUM_CMD, buf_recv, ETP_INF_LENGTH);
+	elantech_i2c_priv->width_x = elantech_i2c_priv->max_x / (buf_recv[0] - 1);
+	elantech_i2c_priv->width_y = elantech_i2c_priv->max_y / (buf_recv[1] - 1);
+	*/
+	/* X Y Value*/
+	input_set_abs_params(dev, ABS_X, 0, elantech_i2c_priv->max_x, 0, 0);
+	input_set_abs_params(dev, ABS_Y, 0, elantech_i2c_priv->max_y, 0, 0);
+	/* Palme Value */
+	input_set_abs_params(dev, ABS_PRESSURE, 0, 255, 0, 0);
+
+	/* Finger Pressure value */
+	//input_set_abs_params(dev, ABS_TOOL_WIDTH, 0, ETP_PRESSURE_MAX, 0, 0);
+	input_set_abs_params(dev, ABS_TOOL_WIDTH, 0, ETP_WMAX_V2, 0, 0);
+
+	/* Finger Pressure value */
+	input_mt_init_slots(dev, ETP_MAX_FINGERS);
+	input_set_abs_params(dev, ABS_MT_POSITION_X, 0, elantech_i2c_priv->max_x, 0, 0);
+	input_set_abs_params(dev, ABS_MT_POSITION_Y, 0, elantech_i2c_priv->max_y, 0, 0);
+	input_set_abs_params(dev, ABS_MT_PRESSURE, 0, ETP_PRESSURE_MAX, 0, 0);
+	//input_set_abs_params(dev, ABS_MT_PRESSURE, 0, ETP_WMAX_V2, 0, 0);
+	input_set_abs_params(dev, ABS_MT_TOUCH_MAJOR, 0, ETP_PRESSURE_MAX, 0, 0);
+	//input_set_abs_params(dev, ABS_MT_TOUCH_MAJOR, 0, ETP_WMAX_V2, 0, 0);
+	input_set_abs_params(dev, ABS_MT_TOUCH_MINOR, 0, ETP_PRESSURE_MAX, 0, 0);
+	//input_set_abs_params(dev, ABS_MT_TOUCH_MINOR, 0, ETP_WMAX_V2, 0, 0);
+
+	/* Enable ABS mode*/
+	//elantech_i2c_command(client, ETP_ENABLE_ABS_CMD, buf_recv, ETP_INF_LENGTH);
+	if ((elan_i2c_asus_cmd_hack(client, NULL, ETP_PS2_CUSTOM_COMMAND)) ||
+			(elan_i2c_asus_cmd_hack(client, NULL, ETP_REGISTER_RW)) ||
+			(elan_i2c_asus_cmd_hack(client, NULL, ETP_PS2_CUSTOM_COMMAND)) ||
+			(elan_i2c_asus_cmd_hack(client, NULL, 0x0010)) ||
+			(elan_i2c_asus_cmd_hack(client, NULL, ETP_PS2_CUSTOM_COMMAND)) ||
+			(elan_i2c_asus_cmd_hack(client, NULL, 0x03)) || // reg_10
+			(elan_i2c_asus_cmd_hack(client, NULL, PSMOUSE_CMD_SETSCALE11)))
+		goto	err_gpio_request;
+
+	gpio = irq_to_gpio(client->irq);
+	/*
+	rc = gpio_request(gpio, label);
+	if (rc < 0) {
+		dev_dbg(&client->dev, "gpio_request failed for input %d rc = %d\n", gpio, rc);
+		goto	err_gpio_request;
+	}
+	rc = gpio_direction_input(gpio);
+	if (rc < 0) {
+		dev_dbg(&client->dev, "gpio_direction_input failed for input %d\n", gpio);
+		goto	err_gpio_request;
+	}
+	*/
+	elantech_i2c_priv->gpio = gpio;
+	/*
+	rc = request_threaded_irq(client->irq, NULL, elantech_i2c_isr,
+			IRQF_TRIGGER_FALLING | IRQF_ONESHOT,
+			client->name, elantech_i2c_priv);
+	 if (rc < 0) {
+		dev_dbg(&client->dev, "Could not register for %s interrupt, irq = %d, rc = %d\n",
+		label, client->irq, rc);
+		goto	err_gpio_request_irq_fail;
+	}
+	*/
+	return elantech_i2c_priv;
+/*
+err_gpio_request_irq_fail:
+	gpio_free(gpio);*/
+err_gpio_request:
+	input_free_device(elantech_i2c_priv->input);
+err_input_allocate_device:
+	kfree(elantech_i2c_priv);
+	return NULL;
+}
+
+void elantech_i2c_report_absolute(struct elantech_i2c *touch,
+				 uint8_t *packet)
+{
+	/*uint8_t *finger_data = &packet[ETP_FINGER_DATA_OFFSET];*/
+	struct input_dev *input = touch->input;
+	/*bool finger_status;*/
+	/*int i;*/
+	int fingers;
+	int position_x, position_y;
+	int mkx_value/*, mky_value*/, h_value;
+
+	//print_hex_dump_bytes("hacking: ", DUMP_PREFIX_NONE, packet,6);
+
+/*// DEFAULT PROTOCOL
+	for (i = 0 ; i < ETP_MAX_FINGERS ; i++) {
+		finger_status = (packet[3] >> (3+i)) & 0x01;
+		if (finger_status) {
+			position_x = ((finger_data[0] & 0xf0) << 4) | finger_data[1];
+			position_y = touch->max_y -
+				(((finger_data[0] & 0x0f) << 8) | finger_data[2]);
+			mkx_value = (finger_data[3] & 0x0f) * touch->width_x;
+			mky_value = (finger_data[3] >> 4) * touch->width_y;
+			h_value = finger_data[4];
+
+			finger_data += ETP_FINGER_DATA_LEN;
+
+			input_mt_slot(input, i);
+			input_mt_report_slot_state(input, MT_TOOL_FINGER, true);
+
+			input_report_abs(input, ABS_MT_POSITION_X, position_x);
+			input_report_abs(input, ABS_MT_POSITION_Y, position_y);
+			input_report_abs(input, ABS_MT_PRESSURE, h_value);
+			input_report_abs(input, ABS_MT_TOUCH_MAJOR, mkx_value);
+			input_report_abs(input, ABS_MT_TOUCH_MINOR, mky_value);
+		} else {
+			input_mt_slot(input, i);
+			input_mt_report_slot_state(input, MT_TOOL_FINGER, false);
+		}
+	}
+	input_report_key(input, BTN_LEFT, ((packet[3] & 0x01) == 1));
+	input_report_key(input, BTN_RIGHT, ((packet[3] & 0x02) == 2));
+	input_report_key(input, BTN_MIDDLE, ((packet[3] & 0x04) == 4));
+	input_mt_report_pointer_emulation(input, true);
+	input_sync(input);
+	*/
+
+	// ASUS PROTOCOL
+	fingers = (packet[0] & 0xc0) >> 6;
+	position_x = ((packet[1] & 0x0f) << 8) | packet[2];
+	position_y = touch->max_y - (((packet[4] & 0x0f) << 8) | packet[5]);
+	mkx_value = ((packet[0] & 0x30) >> 2) | ((packet[3] & 0x30) >> 4);
+	h_value = ((packet[4] & 0xf0) >> 4) | (packet[1] & 0xf0);
+
+	input_report_key(input, BTN_LEFT, (packet[0] & 0x01));
+	input_report_key(input, BTN_RIGHT, (packet[0] & 0x02) >> 1);
+
+
+	switch(fingers)
+	{
+		case 1:
+			input_mt_slot(input, 0);
+			input_mt_report_slot_state(input, MT_TOOL_FINGER, true);
+			input_report_abs(input, ABS_MT_POSITION_X, position_x);
+			input_report_abs(input, ABS_MT_POSITION_Y, position_y);
+			input_report_abs(input, ABS_MT_TOUCH_MAJOR, mkx_value);
+			input_report_abs(input, ABS_MT_PRESSURE, h_value);
+			input_mt_slot(input, 1);
+			input_mt_report_slot_state(input, MT_TOOL_FINGER, false);
+			break;
+		case 2:
+			if ((packet[0] & 0x0c) == 0x04)
+				input_mt_slot(input, 0);
+			else
+				input_mt_slot(input, 1);
+			input_mt_report_slot_state(input, MT_TOOL_FINGER, true);
+			input_report_abs(input, ABS_MT_POSITION_X, position_x);
+			input_report_abs(input, ABS_MT_POSITION_Y, position_y);
+			input_report_abs(input, ABS_MT_TOUCH_MAJOR, mkx_value);
+			input_report_abs(input, ABS_MT_PRESSURE, h_value);
+			break;
+		case 0:
+			input_mt_slot(input, 0);
+			input_mt_report_slot_state(input, MT_TOOL_FINGER, false);
+			input_mt_slot(input, 1);
+			input_mt_report_slot_state(input, MT_TOOL_FINGER, false);
+	}
+	input_mt_report_pointer_emulation(input, true);
+	input_sync(input);
+}
+
diff -urNw stock-kernel/drivers/ril/ril.c linux/drivers/ril/ril.c
--- stock-kernel/drivers/ril/ril.c	2012-09-13 08:32:35.000000000 +0200
+++ linux/drivers/ril/ril.c	2012-11-26 19:38:59.000000000 +0100
@@ -8,7 +8,7 @@
 #include <linux/switch.h>
 #include <linux/uaccess.h>
 #include <linux/workqueue.h>
-#include <../../arch/arm/mach-tegra/include/mach/board-cardhu-misc.h>
+#include "../../arch/arm/mach-tegra/include/mach/board-cardhu-misc.h"
 
 #include "pm-irq.h"
 #include "ril.h"
diff -urNw stock-kernel/net/wireless/chan.c linux/net/wireless/chan.c
--- stock-kernel/net/wireless/chan.c	2012-09-13 08:32:35.000000000 +0200
+++ linux/net/wireless/chan.c	2013-01-16 14:17:01.689868924 +0100
@@ -82,9 +82,12 @@
 {
 	struct ieee80211_channel *chan;
 	int result;
+	struct wireless_dev *mon_dev = NULL;
 
-	if (wdev && wdev->iftype == NL80211_IFTYPE_MONITOR)
+	if (wdev && wdev->iftype == NL80211_IFTYPE_MONITOR) {
+		mon_dev = wdev;
 		wdev = NULL;
+	}
 
 	if (wdev) {
 		ASSERT_WDEV_LOCK(wdev);
@@ -131,5 +134,8 @@
 	if (wdev)
 		wdev->channel = chan;
 
+	if (mon_dev)
+		mon_dev->channel = chan;
+
 	return 0;
 }
